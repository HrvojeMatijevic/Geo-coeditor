<!doctype html>
<html lang="en">
 <head>

    
	<style>
      	.map {
        	width: 99vw;
  		height: 99vh;
      	}
	</style>

<style>
      	.msgarea {
		width: 80%;
        	height:100px;
        	overflow-y: auto
      	}
</style>

<style>
.topleftdata {
  position: absolute;
  top: 30px;
  left: 50px;
  font-size: 18px;
  text-align: left;
  z-index: 1;
  background-color: rgba(200,200,200,.9);
  width: 200px;
  display: inline-block;
  border-radius: 5px;
  overflow: auto; 
}
</style>

<style>
.toprightmessaging {
  position: absolute;
  top: 30px;
  right: 40px;
  font-size: 18px;
  text-align: left;
  z-index: 1;
  background-color: rgba(200,200,200,.9);
  width: 300px;
  display: inline-block;
  border-radius: 5px;
  overflow: auto; 
}
</style>


<style>
p {
  margin: 2px;
  padding: 0;
  line-height: 1;
}
</style>







	<script src="https://cdn.jsdelivr.net/npm/ol@v10.5.0/dist/ol.js"></script>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.5.0/ol.css">

	<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.js"></script>  
	<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.5.0/proj4.js"></script>
	<script src=" https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js "></script>

      
</head>


<body>

   <div id="map" class="map"></div>


   <div class="topleftdata" id="podaci"> 


	<p align="left"><button id="sessionstatus" class="code">Req. session status</button>
	<button id="savereport" class="code">Save report</button></p>
	<button id="enterroom" class="code">Enter room</button></p>
	<p><align="left"><button id="infotoggle" class="code">Togl. conversions</button>
	<align="left"><button style="color:red" id="resetsession" class="code">Reset session</button>
	<align="left"><button style="color:red" id="closeroom" class="code">Close room</button>
	<align="left"><button id="doneediting" class="code">Done editing</button>
	<align="left"><button id="savefeature" class="code">Save feature</button>
<!--	Real time sync <input type="checkbox" id="sendrealtime" name="Send in real time" checked="true">	-->
	Redraw immediately <input type="checkbox" id="redrawimmediately" name="Redraw immediately" >
	Is auto <input type="checkbox" id="isauto" name="Is auto" checked="true">			

<align="left"><button id="startauto" class="code">START auto</button>
<align="left"><button id="stopauto" class="code">STOP auto</button>

<align="left"><button id="register" class="code">Register your name</button>
<input type="text" id="ime" name="ime">

	</p> 

	<p>
	<label> <b>Base map:</b></label>
  	<select class="podloga" name="podloga">
		<option value="none">None</option>
		<option value="dgudof">Orthophoto</option>
   	 	<option value="osm">OSM</option>
  	</select>
	</p> 
<!--		<p><align="left" style="white-space:nowrap">Coords:<span id="ispisKoordinata" ></span>	</p>  --> 
		<p><align="left"><span id="ispisKoordinata" ></span>	</p>

		<p><align="left">Status:<span id="ispisStatusa" ></span>  </p> 
		<p><align="left" >Your name:<span id="ispisImena" ></span> </p>
		<p><align="left">Edits done: <span id="editsdone"> --- </span> </p> 
		<p><align="left" >Users in room:<span id="spojeniKlijenti" ></span> </p>
		<p><align="left" >Users done editing:<span id="gotoviKlijenti" ></span> </p>          
    </div> 

<!--
    <div class="toprightmessaging"> 

		<div style="height: 200px;"> 
		<align="left"><button id="register" class="code">Register your name</button>
		<input type="text" id="ime" name="ime">
		<br> Enter message  <input type="text" id="message" name="message" >
		<div id="klijentispis" class="msgarea"> </div>
     </div>

 -->
    

<script type="text/javascript">

console.log ("Client version 1.09 auto")



//******************************************************************************
//			Configs, global variables and layers
//******************************************************************************

document.getElementById('resetsession').style.visibility='hidden';
document.getElementById('closeroom').style.visibility='hidden';
document.getElementById('infotoggle').style.visibility='hidden';
//document.getElementById('sendrealtime').style.visibility='hidden';

const socket = io.connect('http://192.168.1.120:2500/', {'reconnection': false});


var roomNr;

var runningAuto=true;
var autoOpsGenerated=0;

var opParamsFound=false;
var tempInsertPos;
var tempInsertIdx;
var rangeEndRightId=false;
var rangeEndLeftId=false;
var rangeGotExtended=false;
var tempItemToDelete=false;

var useIndex=true;
var redrawImmediately=false;
var sendRealTime=true;
var bufferSizeLimit=200;

document.getElementById('redrawimmediately').addEventListener('change', function () {
	redrawImmediately=this.checked;
});

document.getElementById('isauto').addEventListener('change', function () {
  	runningAuto=this.checked;
});

var workingFeature;
var initialFeature;
document.getElementById('resetsession').style.visibility='hidden'
document.getElementById('closeroom').style.visibility='hidden'
var unprocessedMessages = [];

var clientId = Math.floor(Math.random() * 100000);
var clientName;
var isInstantiated=false;
var lastInsertPos=0;
var lastLocalInsertPos=0;
var lastRemoteInsertPos = new Map();
var lastViewToModel=0;

var currentlyEditing=false;
var unAppliedCurrentState = false;
var unAppliedMessages = false;
var coordsBefore;

var algorithm;

var vectorSourcePreuzeti = new ol.source.Vector();
var vectorSourceInfo = new ol.source.Vector();
var vectorSourceError = new ol.source.Vector();
var vectorSourceError2 = new ol.source.Vector();
var vectorSourceError3 = new ol.source.Vector();
var vectorSourceError4 = new ol.source.Vector();
var clickCancellations = [];

var vectorSourceOpsPts = new ol.source.Vector();
var vectorSourceOpsLine = new ol.source.Vector();


var vectorSourceDiD = new ol.source.Vector();

var gjsonFormat = new ol.format["GeoJSON"](); 
var sessionReport = [];

var srConversions=0;
var localReorders=0;
var srConversionList=[];
var editsDone=0;
var insertsDone=0;
var updatesDone=0;
var deletesDone=0;
var maxBufferSize=0;
var ooBuffer=0;
var indexRangeHits=0;
var indexRangeMisses=0;

var ukupnoVrijeme=0;
var brojRacunanja=0;
var ukupnoVrijemeOL=0;
var brojRacunanjaOL=0;
var ukupnoVrijemeMV=0;
var brojRacunanjaMV=0;

var remoteExecTimes = [];
var redrawTimes = [];

var peekTime=0;
var peekTimeOL=0;
var peekTimeMV=0;

var firstEdit = 0;
var lastEdit = 0;
var firstGlobalEdit = 0;
var lastGlobalEdit = 0;

var localOpsCoordsList=[];


var lastOpType;
var dragStartTime;
var dragEndTime;
var timeDragging=0;


proj4.defs('EPSG:3765','+proj=tmerc +lat_0=0 +lon_0=16.5 +k=0.9999 +x_0=500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
ol.proj.proj4.register(proj4);
var htrs96 = ol.proj.get('EPSG:3765');



function reInitialize_new(){

crdtDoc = newCRDTDoc();

 //runningAuto=false;
 autoOpsGenerated=0;

 opParamsFound=false;
 tempInsertPos=false;
 tempInsertIdx=false;
 rangeEndRightId=false;
 rangeEndLeftId=false;
 rangeGotExtended=false;
 tempItemToDelete=false;

 workingFeature=undefined;
 initialFeature=undefined;
 unprocessedMessages = [];

 isInstantiated=false;
 lastInsertPos=0;
 lastLocalInsertPos=0;
 lastRemoteInsertPos.clear();

 currentlyEditing=false;
 unAppliedCurrentState = false;
 unAppliedMessages = false;
 coordsBefore;

 algorithm=undefined;


 vectorSourcePreuzeti.clear();
 vectorSourceInfo.clear();
 vectorSourceError.clear();
 vectorSourceError2.clear();
 vectorSourceError3.clear();
 vectorSourceError4.clear();
 vectorSourceOpsPts.clear();
 vectorSourceOpsLine.clear();
 vectorSourceDiD.clear();

  clickCancellations = [];
  remoteExecTimes = [];
  redrawTimes = [];


 gjsonFormat = new ol.format["GeoJSON"](); 
 sessionReport = [];

 srConversions=0;
 localReorders=0;
 srConversionList=[];
 editsDone=0;
 insertsDone=0;
 updatesDone=0;
 deletesDone=0;
 maxBufferSize=0;
 ooBuffer=0;
 indexRangeHits=0;

 ukupnoVrijeme=0;
 brojRacunanja=0;
 peekTime=0;
 ukupnoVrijemeOL=0;
 brojRacunanjaOL=0;
 peekTimeOL=0;
 ukupnoVrijemeMV=0;
 brojRacunanjaMV=0;
 peekTimeMV=0;

 firstEdit = 0;
 lastEdit = 0;
 firstGlobalEdit = 0;
 lastGlobalEdit = 0;

 localOpsCoordsList=[];


 lastOpType=undefined;
 dragStartTime=undefined;
 dragEndTime=undefined;
 timeDragging=0;
}



const stiloviPoligona = [
  new ol.style.Style({
    stroke: new ol.style.Stroke({
      color: 'black',
      width: 2,
    }),
    fill: new ol.style.Fill({
      color: 'rgba(0, 0, 255, 0.1)',
    }),
   //text: function (feature) {return new ol.style.Text({text: feature.getId()})}
  }),
  new ol.style.Style({
    image: new ol.style.Circle({
      radius: 4,
      fill: new ol.style.Fill({
        color: 'orange',
      }),
    }),
    geometry: function (feature) {
      // return the coordinates of the first ring of the polygon
      var coordinates = feature.getGeometry().getCoordinates()[0][0];
      return new ol.geom.Point(coordinates);
    },
  }),
new ol.style.Style({
    image: new ol.style.Circle({
      radius: 2,
      fill: new ol.style.Fill({
        color: 'red',
      }),
    }),
    geometry: function (feature) {
      var coordinates = feature.getGeometry().getCoordinates()[0];
      return new ol.geom.MultiPoint(coordinates);
    },
  }),

];


const stiloviPoligonaBez = [
  new ol.style.Style({
    stroke: new ol.style.Stroke({
      color: 'black',
      width: 2,
    }),
    fill: new ol.style.Fill({
      color: 'rgba(0, 0, 255, 0.1)',
    }),
  }),
  new ol.style.Style({
    image: new ol.style.Circle({
      radius: 4,
      fill: new ol.style.Fill({
        color: 'orange',
      }),
    }),
    geometry: function (feature) {
      // return the coordinates of the first ring of the polygon
      var coordinates = feature.getGeometry().getCoordinates()[0][0];
      return new ol.geom.Point(coordinates);
    },
  })
];



const stiloviPoligonaSelect = [
  new ol.style.Style({
    stroke: new ol.style.Stroke({
      //color: '#0eff00',
	//color: 'black',
      width: 1,
    }),
    fill: new ol.style.Fill({
      color: 'rgba(0, 255, 0, 0)',
    }),
   //text: function (feature) {return new ol.style.Text({text: feature.getId()})}
  }),
 new ol.style.Style({
    image: new ol.style.Circle({
      radius: 4,
      fill: new ol.style.Fill({
        color: 'orange',
      }),
    }),
    geometry: function (feature) {
      // return the coordinates of the first ring of the polygon
      var coordinates = feature.getGeometry().getCoordinates()[0][0];
      return new ol.geom.Point(coordinates);
    },
  }),
new ol.style.Style({
    image: new ol.style.Circle({
      radius: 2,
      fill: new ol.style.Fill({
        color: 'red',
      }),
    }),
    geometry: function (feature) {
      var coordinates = feature.getGeometry().getCoordinates()[0];
      return new ol.geom.MultiPoint(coordinates);
    },
  }),
];


const stiloviPoligonaSelectBez = [
  new ol.style.Style({
    stroke: new ol.style.Stroke({
      //color: '#0eff00',
	//color: 'black',
      width: 1,
    }),
    fill: new ol.style.Fill({
      color: 'rgba(0, 255, 0, 0)',
    }),
   //text: function (feature) {return new ol.style.Text({text: feature.getId()})}
  }),
 new ol.style.Style({
    image: new ol.style.Circle({
      radius: 4,
      fill: new ol.style.Fill({
        color: 'orange',
      }),
    }),
    geometry: function (feature) {
      // return the coordinates of the first ring of the polygon
      var coordinates = feature.getGeometry().getCoordinates()[0][0];
      return new ol.geom.Point(coordinates);
    },
  })
];

const stiloviPoligonaModify = [
new ol.style.Style({
    image: new ol.style.Circle({
      radius: 3,
      fill: new ol.style.Fill({
        color: '#00FF00',
      }),
    }),
   
  }),
];

const stilInfo = [
          // Linestring
          new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: '#00FF00',
                width: 2
            })
        }),
];

const stilError = [
     new ol.style.Style({
    		image: new ol.style.Circle({
      		radius: 5,
      		fill: new ol.style.Fill({color: '#00FF00'}),
      		stroke: new ol.style.Stroke({color: '#00FF00', width: 2})
       		})
     })     
];

const stilError2 = [
     new ol.style.Style({
    		image: new ol.style.RegularShape({
      		fill: new ol.style.Fill({color: 'purple'}),
      		stroke: new ol.style.Stroke({color: 'purple', width: 2}),
		points: 4,
      		radius: 5,
      		radius2: 0,
      		angle: Math.PI / 4,
       		})
     })     
];

const stilError3 = [
     new ol.style.Style({
    		image: new ol.style.Circle({
      		radius: 4,
      		fill: new ol.style.Fill({color: 'yellow'}),
      		stroke: new ol.style.Stroke({color: 'yellow', width: 2})
       		})
     })     
];


const stilError4 = [
     new ol.style.Style({
    		image: new ol.style.RegularShape({
      		fill: new ol.style.Fill({color: 'red'}),
      		stroke: new ol.style.Stroke({color: 'red', width: 3}),
		points: 4,
      		radius: 5,
      		radius2: 0,
      		angle: Math.PI / 4,
       		})
     })     
];




var vectorSlojPreuzeti = new ol.layer.Vector({
        source: vectorSourcePreuzeti,
           minResolution: 0.01,
           maxResolution: 100000,
        visible: true,
        title: 'Važeće stanje',
        style: stiloviPoligonaBez
      });

var vectorSlojInfo = new ol.layer.Vector({
        source: vectorSourceInfo,
           minResolution: 0.01,
           maxResolution: 100000,
        visible: false,
        title: 'Info',
        style: stilInfo
      });

var vectorSlojError = new ol.layer.Vector({
        source: vectorSourceError,
           minResolution: 0.01,
           maxResolution: 100000,
        visible: false,
        title: 'Error',
        style: stilError
      });

var vectorSlojError2 = new ol.layer.Vector({
        source: vectorSourceError2,
           minResolution: 0.01,
           maxResolution: 100000,
        visible: false,
        title: 'Error',
        style: stilError2
      });

var vectorSlojError3 = new ol.layer.Vector({
        source: vectorSourceError3,
           minResolution: 0.01,
           maxResolution: 100000,
        visible: false,
        title: 'Error',
        style: stilError3
      });

var vectorSlojError4 = new ol.layer.Vector({
        source: vectorSourceError4,
           minResolution: 0.01,
           maxResolution: 100000,
        visible: false,
        title: 'Error',
        style: stilError4
      });




const DOF = new ol.layer.Tile({
            title: 'DOF 2011',
            type: 'base',
            visible: true,
            source: new ol.source.TileWMS({
            //url: 'https://geoportal.dgu.hr/services/inspire/orthophoto_2019_2020/wms',
	    url: 'https://geoportal.dgu.hr/services/inspire/orthophoto_2011/wms',
            //params: {'LAYERS': 'OI.OrthoimageCoverage', 'TILED': true} 
	    params: {'LAYERS': 'OrthoImagery', 'TILED': true},
	    attributions: `<a href="https://geoportal.dgu.hr/#/menu/podaci-i-servisi">Geoportal Državne geodetske uprave</a>`                  
                    })
           });   

const osm = new ol.layer.Tile({source: new ol.source.OSM()});
     

  
  

//******************************************************************
//                           Drag & drop geoJSON geometry to map
//******************************************************************

      

	var dragAndDropInteraction = new ol.interaction.DragAndDrop({
       	 formatConstructors: [
       	   ol.format.GPX,
       	   ol.format.GeoJSON,
       	   ol.format.IGC,
       	   ol.format.KML,
       	   ol.format.TopoJSON
       	 ]
	}); 


	dragAndDropInteraction.on('addfeatures', function(event) {
         
          	vectorSourcePreuzeti.addFeatures(event.features);
		workingFeature = vectorSourcePreuzeti.getFeatures()[0];	
		var coords=workingFeature.getGeometry().getCoordinates()[0];
		map.getView().fit(vectorSourcePreuzeti.getExtent());		

		// We do not insert the last point which is identical to the first (thus: coords.length-1).
		for (var i = 0; i < coords.length-1; i++) {
			tempInsertIdx=i		
			var dodani= localInsert(crdtDoc, clientId, i, coords[i], true, false); 
		}
			socket.emit('CRDT object creation',  {crdtdoc:crdtDoc})			
			isInstantiated=true;

		initialFeature=workingFeature.clone();
		firstGlobalEdit = 0;

 	});




//**********************************************************
//Instancing map, view, etc...
//************************************************************


    var view = new ol.View({
	  projection: htrs96,
          minResolution: 0.05,
            center: [625000, 5020000],
          zoom: 12
        })


     var map = new ol.Map({
        target: 'map',
        view: view
      });



	map.addInteraction(dragAndDropInteraction);
        map.addLayer(DOF);	
	map.addLayer(osm);	
	map.addLayer(vectorSlojPreuzeti);
	map.addLayer(vectorSlojInfo);
	map.addLayer(vectorSlojError);
	map.addLayer(vectorSlojError3);
        map.addLayer(vectorSlojError4);
	map.addLayer(vectorSlojError2);
	
	DOF.setVisible (false); 
	osm.setVisible (false)	

     var mousePositionControl = new ol.control.MousePosition({
        coordinateFormat: ol.coordinate.createStringXY(1),
        className: 'custom-mouse-position',
        target: document.getElementById("ispisKoordinata"),
        undefinedHTML: ''
      });

	map.addControl(mousePositionControl);

	const selectElement = document.querySelector('.podloga');
		selectElement.addEventListener('change', (event) => {
  		//console.log (event.target.value);
		if (event.target.value=='dgudof') {DOF.setVisible (true); osm.setVisible (false)}     
		if (event.target.value=='osm') {DOF.setVisible (false); osm.setVisible (true)} 
		if (event.target.value=='none') {DOF.setVisible (false); osm.setVisible (false)}       
	});   



//********************************************************
//             Buttons
//********************************************************


document.getElementById('sessionstatus').onclick = function() {
		requestSessionStatus();
		console.log ("------------Session status requested---------------------")
};


document.getElementById('register').onclick = function() {
		clientName=document.getElementById("ime").value;
		if (clientName != "") {
			socket.emit('send id', {clientId: clientId, name:clientName});
			document.getElementById('register').style.visibility='hidden';
			document.getElementById('ime').style.visibility='hidden';
			document.getElementById("ispisImena").textContent=clientName;
		}
		else alert ("Please enter your name first...");
};

document.getElementById('resetsession').onclick = function() {
		var poruka= {doReset:true};
		socket.emit('reset session',  poruka );
};

document.getElementById('closeroom').onclick = function() {
		var poruka= {doCloseRoom:true};
		socket.emit('close room',  poruka );
};


document.getElementById('doneediting').onclick = function() {
		var poruka= {done:true};
		socket.emit('done editing',  poruka );

	currentlyEditing=false
	document.getElementById('ispisKoordinata').style.color='green';

	if (unAppliedMessages) {
		var didAnything=integrateMessagesFromBuffer();
		if (didAnything) applyCurrentState (); 
		unAppliedMessages=false;
	} 
};


document.getElementById('infotoggle').onclick = function() {
		if (vectorSlojInfo.getVisible())  {vectorSlojInfo.setVisible(false); vectorSlojError.setVisible(false); vectorSlojError2.setVisible(false); vectorSlojError3.setVisible(false)}
		else {vectorSlojInfo.setVisible(true); vectorSlojError.setVisible(true); vectorSlojError2.setVisible(true); vectorSlojError3.setVisible(true);}
};


//(vectorSourceError) - conflict resolved by CRDT distance based ordering 
//(vectorSourceError2) - an error where tentative positioning should have been done, but did not 
//(vectorSourceError3) - processed as tentative operation 
//(clickCancellations array) - an error where initial tentative parameters could not have been done (clickCancellations array)

document.getElementById('savereport').onclick = function() {

		//var geoJsonInfo = gjsonFormat.writeFeatures(vectorSourceInfo.getFeatures(), { dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'});
		//var geoJsonError = gjsonFormat.writeFeatures(vectorSourceError.getFeatures(), { dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'});

		var geoJsonInfo = gjsonFormat.writeFeatures(vectorSourceInfo.getFeatures());
		var geoJsonError = gjsonFormat.writeFeatures(vectorSourceError.getFeatures());
		var geoJsonError2 = gjsonFormat.writeFeatures(vectorSourceError2.getFeatures());
		var geoJsonError3 = gjsonFormat.writeFeatures(vectorSourceError3.getFeatures());
		 
		var both="REPORT:" + JSON.stringify(sessionReport) + 
			"\n--CRDT distance based ordering connectors:" + geoJsonInfo+ 
			"\n--CRDT distance based ordering locations:" + geoJsonError + 
			"\n--ERRORS:Tentative algorithm could not position operation:" + geoJsonError2  +
			"\n--Correctly processed tentative operations:" + geoJsonError3 + 
			"\n--ERRORS: tentative operation could not be initiated from OL dragsegments" + JSON.stringify(clickCancellations);


		var blob = new Blob([both], {type: "text/plain;charset=utf-8"});
		saveAs(blob, "crdtSessionReport_.txt");
};


document.getElementById('enterroom').onclick = function() {
	var userText=prompt ("Broj sobe je");
	var tokens=userText.split(",");
	var roomNr=tokens[0];
	var roomKey=tokens[1];

	var poruka= {roomNr:roomNr, roomKey:roomKey};
	socket.emit('join room',  poruka );


};

document.getElementById('savefeature').onclick = function() {
	saveFeatures(vectorSourcePreuzeti.getFeatures());
};





//******************************************************************** SESSIONS REPORTING ******************************************************

function requestSessionStatus () {
			
			var coordsToSend=workingFeature.getGeometry().getCoordinates()[0];	
			socket.emit('Session status request',  {coords:coordsToSend} );	
}



function reportSessionStatus (msg) {
			var convergenceStatus;
			var myCoords=workingFeature.getGeometry().getCoordinates()[0];	
			var remoteCoords=msg.coords;

			var localOps = JSON.parse(gjsonFormat.writeFeatures(vectorSourceOpsPts.getFeatures()));
			
			if (JSON.stringify(myCoords) === JSON.stringify(remoteCoords)) {
					convergenceStatus=true;
				} else {
					convergenceStatus=false;
					console.log (JSON.stringify(myCoords))
					console.log (JSON.stringify(remoteCoords))
			}

			var localOpsLs = new ol.geom.LineString(localOpsCoordsList);
			var localOpsLineFeat= new ol.Feature({geometry: localOpsLs});
			vectorSourceOpsLine.addFeature(localOpsLineFeat);
			var localOpsLs = JSON.parse(gjsonFormat.writeFeatures(vectorSourceOpsLine.getFeatures()));

		if (firstEdit!=0){
			socket.emit('Session status report',  {browser: navigator.userAgent,
							       algorithm:algorithm,
							       clientId:clientId,
							       clientName: clientName,
							       editsDone: editsDone,
							       insertsDone: insertsDone,
							       updatesDone: updatesDone,
							       deletesDone: deletesDone,
							       maxBufferSize: maxBufferSize,
							       ooBuffer: ooBuffer,
							       convergenceStatus:convergenceStatus,
							       srConversions:srConversions,
							       srConversionList:JSON.stringify(srConversionList),
							       localReorders: localReorders,
							       duration: ((lastEdit-firstEdit)/1000).toFixed(),
							       globalDuration: ((lastGlobalEdit-firstGlobalEdit)/1000).toFixed(),
							       timeDragging: (timeDragging/1000).toFixed(),
				                               vertexCount: workingFeature.getGeometry().getCoordinates()[0].length,
							       localOps: localOps,
							       remoteExecTimes:remoteExecTimes,
							       redrawTimes:redrawTimes,
							       localOpsLs: localOpsLs});	
		} else {

			socket.emit('Session status report',  {clientId:clientId,
							       clientName: clientName,
							       convergenceStatus:convergenceStatus,
							       autoOpsGenerated:autoOpsGenerated});
		}

}




//**************************************************** SOCKET IO EVENTS **********************************


socket.on('connected', function (data) {
	if (socket.recovered) {
  		document.getElementById("ispisStatusa").textContent="You are REconnected";
		document.getElementById("ispisStatusa").style.color='green';
		document.getElementById("ispisStatusa").style.fontWeight='bold';

	} else {
		//if (firstEdit==0) firstEdit=performance.now();
		algorithm=data.algorithm;
		//alert ("You are connected, algorithm=" + algorithm + ", please enter your name and register...");
		document.getElementById("ispisStatusa").textContent="You are connected";
		document.getElementById("ispisStatusa").style.color='green';
		document.getElementById("ispisStatusa").style.fontWeight='bold';
  	}
});


socket.on('disconnect', function (data) {
	document.getElementById("ispisStatusa").textContent="You have been disconnected";
	document.getElementById("ispisStatusa").style.color='red';
	document.getElementById("ispisStatusa").style.fontWeight='bold';
	selektiranje2.setActive(false);
	editiranje.setActive(false);
	mouseClickController.setActive(false);
});


socket.on('participant update', function (data) {
	var popis="";
	var popis1="";
	
	var brojac=0
	for (var c in data) {
		if (data[c].status>1 && data[c].status<4) {
			brojac++; popis=popis + " " + brojac + "." +data[c].name
		} else if (data[c].status==4) {
			 popis1=popis1 + " " +data[c].name
		}
	}

	document.getElementById("spojeniKlijenti").textContent=popis;
	document.getElementById("gotoviKlijenti").textContent=popis1;
	

});



socket.on('controller', function (data) {
	document.getElementById('resetsession').style.visibility='visible';
	document.getElementById('closeroom').style.visibility='visible';
	document.getElementById('infotoggle').style.visibility='visible';
	vectorSlojInfo.setVisible(true);
        vectorSlojError.setVisible(true); 
	vectorSlojError2.setVisible(true); 
	vectorSlojError3.setVisible(true);
});

socket.on('chat message', function (msg) {
	var el=document.getElementById('klijentispis');
	var content = document.createElement ("p");
	//content.innerHTML=JSON.stringify(msg.clientName) + ": " + JSON.stringify(msg.msg);
	content.innerHTML=msg.clientName + ": " + msg.msg;
	el.insertBefore(content, el.firstChild);
});

socket.on('controller', function (msg) {
	socket.emit('Algorithm setup',  {algorithm: "YJS"});
});


socket.on('client reset', function (msg) {
	reInitialize_new();
});

socket.on('Session status request', function (msg) {
	sessionReport=[];
	reportSessionStatus(msg);
});


socket.on('Session status report', function (msg) {
	console.log(JSON.stringify(msg));
	sessionReport.push(msg);
});

socket.on('CRDT change creation', function (data) {
	processMessageCRDT(data);
});


socket.on('Conversion data', function (data) {
	var infoLs = new ol.geom.LineString(data.geom);
	var infoFeat= new ol.Feature({geometry: infoLs});
	infoFeat.setId(data.id);
	//infoFeat.set("time", data.time);
	//infoFeat.set("opType", data.opType);
	vectorSourceInfo.addFeature(infoFeat);	
});

//MESSAGE TYPES
//type 1 - conflict resolved by CRDT distance based ordering (vectorSourceError)
//type 2 - an error where tentative positioning should have been done, but did not (vectorSourceError2)
//type 3 - processed as tentative operation (vectorSourceError3)
//type 4 - an error where initial tentative parameters could not have been done (clickCancellations array)
socket.on('Error data', function (data) {

if (data.type==1) {
	var ft = vectorSourceError.getFeatureById(data.id);
	if (ft) {
		var convs=parseInt(ft.get("convs"));
		convs++ ;
		ft.set("convs", convs);
	} else {
		var infoPt = new ol.geom.Point(data.geom);
		var infoFeat= new ol.Feature({geometry: infoPt});
		infoFeat.setId(data.id);
		infoFeat.set("mode", data.mode);
		infoFeat.set("convs", 1);
		infoFeat.set("opType", data.opType);
		infoFeat.set("time", data.time);
		vectorSourceError.addFeature(infoFeat);	
	}
} else if (data.type==2){
		var infoPt = new ol.geom.Point(data.geom);
		var infoFeat= new ol.Feature({geometry: infoPt});
		vectorSourceError2.addFeature(infoFeat);	
} else if (data.type==3){
		var infoPt = new ol.geom.Point(data.geom);
		var infoFeat= new ol.Feature({geometry: infoPt});
		infoFeat.set("opType", data.opType);
		infoFeat.set("siteId", data.siteId);
		infoFeat.set("time", data.time);
		infoFeat.set("bufferedOps", data.bufferedOps);
		infoFeat.set("duration", data.duration);
		vectorSourceError3.addFeature(infoFeat);	
} else if (data.type==4){
		clickCancellations.push (data);	
} else if (data.type==5){
		var targetGroup=data.targetGroup;
		if (clientName==targetGroup) {
			//gen.startLoop();
			autoDisplaySource.addFeature (positionFeature);
			//runningAuto=true
		}
} else if (data.type==6){
		//gen.stopLoop();
		//autoDisplaySource.removeFeature (positionFeature)
		//runningAuto=false;
		applyCurrentState (); // Because auto clients do not apply as they work
}


});



// This is used only when transferring results of D&D (also for late join-ins) to speed up instatiation on receiving clients 
// by avoiding redraws for each received operation

socket.on('CRDT object creation', function (data) {
    crdtDoc.content=data.crdtdoc.content;
    crdtDoc.version=data.crdtdoc.version;
    crdtDoc.length=data.crdtdoc.length;
    crdtDoc.maxSeq=data.crdtdoc.maxSeq;
    
    var didAnything=integrateMessagesFromBuffer();

    isInstantiated=false;
    applyCurrentState (); 
    socket.emit('resource acquired',  {dummy: null});
});

socket.on('request current', function (data) {
	if (isInstantiated) {
		console.log ("about to deliver current to " + data.clientid)
		socket.emit('deliver current',  {crdtdoc:crdtDoc, clientid:data.clientid})
	}		
});

socket.on('room access response', function (data) {
	alert (data.message)	
	if (data.status==2) {
		socket.emit('request current',  {clientid: socket.id});	
		document.getElementById("ispisStatusa").textContent="You are in room " + data.room;
	}
});




//******************************************************  PRIMARY CONTROL PROTOCOL *********************************************

//CRDT DELTA APPLYING AND PROCESSING ON MODIFYEND
//Upon each modifyEnd event the operation is composed using the parameters from GUI and transmitted to server.
//after that, if there were received and integrated changes a redraw is done.

//async function postModifyProcessorCRDT (trans) {
function postModifyProcessorCRDT (trans) {
	
	crdtDoc.outQueue.push(trans);
	if (sendRealTime) {
		var currQuLen=crdtDoc.outQueue.length;
	// SECTION : delta  transmitter
		for (var i = 0; i < currQuLen; i++) {
			var msg=crdtDoc.outQueue[0];
			socket.emit('CRDT change creation',  {delta:msg} );
			crdtDoc.outQueue.shift();
			console.log ("SENT " + msg)
		}
	}

	
	applyCurrentState (); 	
	currentlyEditing=false;
	document.getElementById('ispisKoordinata').style.color='green';
}


// Takes the received message and decides whether to apply immediately or deffered (if the user currently drags)
function processMessageCRDT(data){
	if (firstGlobalEdit == 0) firstGlobalEdit=performance.now ();
	lastGlobalEdit = performance.now ();
	unprocessedMessages.push(data.delta);
	console.log ("processing " + data.delta)
	if (unprocessedMessages.length>maxBufferSize) {maxBufferSize=unprocessedMessages.length}
	
	//if (currentlyEditing || !isInstantiated || (!redrawImmediately && selektiranje2.getFeatures().getArray().length>0 && unprocessedMessages.length<bufferSizeLimit) ) {
	if (currentlyEditing || !isInstantiated || (!redrawImmediately && selektiranje2.getFeatures().getArray().length>0) ) {
		unAppliedMessages = true;
	} else {
		var didAnything=integrateMessagesFromBuffer();
		if (!runningAuto) applyCurrentState (); 
	}
	
	if (sendRealTime) {
		var currQuLen=crdtDoc.outQueue.length;
		// SECTION : delta  transmitter
		for (var i = 0; i < currQuLen; i++) {
			var msg=crdtDoc.outQueue[0];
			socket.emit('CRDT change creation',  {delta:msg} );
			crdtDoc.outQueue.shift();
		}
	}

};



function integrateMessagesFromBuffer(){
     var didAnything=false;
     var lastTurnDidAnything=true;
     var lastRunTimings={}
     var insertsProcessed=0
     var updatesProcessed=0
     var deletesProcessed=0
     indexRangeHits=0;
     indexRangeMisses=0;
     var startTime = performance.now();
     var atTimeInstant=((startTime-firstGlobalEdit)/1000).toFixed();
     var nrMessages=unprocessedMessages.length

  // Repeat processing until we reach a turn where nothing happened or array empty  
  while (unprocessedMessages.length>0 && lastTurnDidAnything) {
     lastTurnDidAnything=false;
     var ctr=0; // Custom counter for array index
     
     // Process messeages and delete those that got integrated sequentially forward from the start of array (in order of arrival)
     while (unprocessedMessages.length>0 && ctr<unprocessedMessages.length) {
	var iCanDelete;
	var iCanInsert;
	var deletePos;
	var alreadyInserted=false;
	var alreadyDeleted=false;
	var thisClientsLastInsertPos = 0;
	var foundDeletePos = 0;
	var thisClientId;
	var idx_hint=0;

	thisClientId=unprocessedMessages [ctr].clientId // 1.04AUTO addition
	if (lastRemoteInsertPos.has (thisClientId)) {
		thisClientsLastInsertPos = lastRemoteInsertPos.get (thisClientId)
		if (useIndex) idx_hint=thisClientsLastInsertPos  // v1.02 addition
	}

	// Is there something to integrate, and can we?
	if (unprocessedMessages [ctr].new.id !== undefined) {
		//thisClientId=unprocessedMessages [ctr].new.id[0]
		if (lastRemoteInsertPos.has (thisClientId)) {
			thisClientsLastInsertPos = lastRemoteInsertPos.get (thisClientId)
			if (useIndex) idx_hint=thisClientsLastInsertPos  // v1.02 addition
		}
		iCanInsert = canInsertNow  (messageToItem(unprocessedMessages [ctr].new), crdtDoc);
		alreadyInserted=isInVersion(unprocessedMessages [ctr].new.id, crdtDoc.version)

	} else {iCanInsert=true}




	// 1. Is there something to delete, and can we?
	if (unprocessedMessages [ctr].del.id !== undefined) {
		iCanDelete = canDeleteNow  (messageToItem(unprocessedMessages [ctr].del), crdtDoc);
		// Perhaps its already deleted. Let's check.
		if (iCanDelete) {
			const itemPos=findItem(crdtDoc, unprocessedMessages [ctr].del.id, idx_hint)
			foundDeletePos=itemPos
			lastRemoteInsertPos.set (thisClientId, foundDeletePos); // v1.02 addition
			if (useIndex) idx_hint=foundDeletePos  // v1.02 addition
  			const item = crdtDoc.content [itemPos]
  			if (item.isDeleted) alreadyDeleted=true
		}

	} else {iCanDelete=true}

	

	// If the message is alreadyDeleted and alreadyInserted then its already integrated and needn't be processed
	// and can be deleted from inbuffer
	if (alreadyDeleted && alreadyInserted) {
		unprocessedMessages.splice (ctr,1);
		ctr--;
		console.log ("!!!redundant!!!")
	// if not redundant then we process it only if atomic (both delete and insert are executable)
	} else if (iCanDelete && iCanInsert) {
		didAnything=true;
		lastTurnDidAnything=true;
		if (unprocessedMessages [ctr].del.id !== undefined && unprocessedMessages [ctr].new.id !== undefined) {lastOpType="upd";updatesProcessed++}
		else if (unprocessedMessages [ctr].del.id === undefined && unprocessedMessages [ctr].new.id !== undefined) {lastOpType="ins"; insertsProcessed++}
		else {lastOpType="del"; deletesProcessed++}

		// Delete if there is something to.
		// 1. We first do the delete part.
		if (unprocessedMessages [ctr].del.id !== undefined) {
			deletePos=localDeleteFromOther (crdtDoc, unprocessedMessages [ctr].del, idx_hint);
			//lastRemoteInsertPos.set (thisClientId, deletePos); // Don't set to delete pos since the deleted item needn't be this client's
		} 

		// Insert if there is something to.
		// 2. Then we insert.
		if (unprocessedMessages [ctr].new.id !== undefined) {

				//await integrateYjs(crdtDoc, messageToItem(unprocessedMessages [ctr].new) , thisClientsLastInsertPos);
				integrateYjs(crdtDoc, messageToItem(unprocessedMessages [ctr].new) , idx_hint);
				var coord=messageToItem(unprocessedMessages [ctr].new).content;
				lastRemoteInsertPos.set (thisClientId, lastInsertPos);
				//unprocessedMessages [ctr].new={};

		} 

		// Resyncing of the range upon integrating update and delete ops

		if (rangeEndLeftId && lastOpType=="upd") {
			if (idEq2(rangeEndLeftId, unprocessedMessages [ctr].del.id[0], unprocessedMessages [ctr].del.id[1])) {
				var rangeEndLeftIdx=getPreviousUndeletedItemIdx (crdtDoc, thisClientsLastInsertPos)
				rangeEndLeftId=crdtDoc.content[rangeEndLeftIdx].id
				rangeGotExtended=true
				//console.log ("REL PUSHED BACK BY REMOTE UPDATE")
			}
		}

		if (rangeEndRightId && lastOpType=="upd") {
			if (idEq2(rangeEndRightId, unprocessedMessages [ctr].del.id[0], unprocessedMessages [ctr].del.id[1])) {
				var rangeEndRightIdx=getNextUndeletedItemIdx (crdtDoc, thisClientsLastInsertPos)
				rangeEndRightId=crdtDoc.content[rangeEndRightIdx].id
				rangeGotExtended=true
				//console.log ("RER PUSHED FWD BY REMOTE UPDATE")
			}
		}

		if (rangeEndLeftId && lastOpType=="del") {
			if (idEq2(rangeEndLeftId, unprocessedMessages [ctr].del.id[0], unprocessedMessages [ctr].del.id[1])) {
				var rangeEndLeftIdx=getPreviousUndeletedItemIdx (crdtDoc, deletePos)
				rangeEndLeftId=crdtDoc.content[rangeEndLeftIdx].id
				rangeGotExtended=true
				//console.log ("REL PUSHED BACK BY REMOTE DELETE")
			}
		}

		if (rangeEndRightId && lastOpType=="del") {
			if (idEq2(rangeEndRightId, unprocessedMessages [ctr].del.id[0], unprocessedMessages [ctr].del.id[1])) {
				var rangeEndRightIdx=getNextUndeletedItemIdx (crdtDoc, deletePos)
				rangeEndRightId=crdtDoc.content[rangeEndRightIdx].id
				rangeGotExtended=true
				//console.log ("RER PUSHED FWD BY REMOTE DELETE")
			}
		}

		// End of resyncing of the range upon integrating update and delete ops

		// Finnaly, delete the message from buffer
		unprocessedMessages.splice (ctr,1);
		ctr--;

		
	}

	ctr++;

    } // Inner while loop
  } // Outer while

if (didAnything) {
  var endTime = performance.now()
  lastRunTimings.atTimeInstant=atTimeInstant
  lastRunTimings.messagesInBuffer=nrMessages
  lastRunTimings.insertsProcessed=insertsProcessed
  lastRunTimings.updatesProcessed=updatesProcessed
  lastRunTimings.deletesProcessed=deletesProcessed
  lastRunTimings.indexRangeHits=indexRangeHits
  lastRunTimings.indexRangeMisses=indexRangeMisses
  lastRunTimings.duration=(endTime-startTime).toFixed(2)
  remoteExecTimes.push(lastRunTimings)
}


  return didAnything;
};




function applyCurrentState () {
	var skipTiming=false;
	var lastRunTimings={}
	var startTime = performance.now();
	var atTimeInstant=((startTime-firstGlobalEdit)/1000).toFixed();		
	var newState=getArray(crdtDoc);
	var polyOriginItemIdx=getNextUndeletedItemIdx (crdtDoc, -1)
	var polyOriginPoint=crdtDoc.content[polyOriginItemIdx].content
	newState.push (polyOriginPoint); // We need to always copy the first undeleted point to last position in order for polygon to be correct
	var endTimeMV = performance.now();
	if (!isInstantiated) {
		var olGeometrija= new ol.geom.Polygon([newState]);
		workingFeature = new ol.Feature({geometry: olGeometrija});
		vectorSourcePreuzeti.addFeature (workingFeature); 
		map.getView().fit(vectorSourcePreuzeti.getExtent());	
		isInstantiated=true;
		skipTiming=true;
		//Some margin is left to compensate for the limits not being dynamically adjusted 
		//to changes in the doc size. Initially crdtDoc.content.length will be equal to crdtDoc.length
		var upper= crdtDoc.content.length-10000
		var lower = Math.floor(2*(crdtDoc.content.length/3));
		console.log ("Range=" + upper + "-"+lower)
		gen.setPositionRange( { from: lower, to: upper });
	} else {
		//Preparation for the redrawing of geometry on GUI
		var newGeom = new ol.geom.Polygon([newState]);
		//Actual Redrawing on GUI happens here
		workingFeature.setGeometry(newGeom);
		if (newState.length==3) {map.getView().fit(vectorSourcePreuzeti.getExtent())}	
	}
	var endTimeOL = performance.now();
	if (!skipTiming) { 
		//mjerenjePerformansiOL (startTime,endTimeOL);
		//mjerenjePerformansiMV (startTime,endTimeMV);
  		var endTime = performance.now();
  		lastRunTimings.atTimeInstant=atTimeInstant
    		lastRunTimings.durationOL=(endTimeOL-startTime).toFixed(2)
		lastRunTimings.currentZoomLevel=view.getZoom().toFixed()
		lastRunTimings.durationMV=(endTimeMV-startTime).toFixed(2)
  		redrawTimes.push(lastRunTimings)
	}

}


function messageToItem(itemDataIn){

	return {
		content: itemDataIn.content,
        	id: itemDataIn.id,
        	isDeleted: itemDataIn.isDeleted,
        	originLeft: itemDataIn.originLeft,
        	originRight: itemDataIn.originRight,
        	insertAfter: true,
        	seq: itemDataIn.seq, // Only for AM.
    		}
}






//*****************************************************************************************************************************
//*****************************************  REFERENCE CRDTs  *****************************************************************
//*****************************************************************************************************************************

var newCRDTDoc = function () { return ({
    content: [],
    version: {},
    length: 0,
    maxSeq: 0,
    outQueue: [] // Out queue is used to get the ability to postpone transmitting of operations.
}); };

let crdtDoc = newCRDTDoc();

// **** Common code and helpers
// We never actually compare the third argument in sync9.
var idEq2 = function (a, agent, seq) { return (a != null && (a[0] === agent && a[1] === seq)); };
var idEq = function (a, b) { return (a == b || (a != null && b != null && a[0] === b[0] && a[1] === b[1])); };
var hits = 0;
var misses = 0;


// idx_hint is a small optimization so when we know the general area of
// an item, we search nearby instead of just scanning the whole document.
var findItem2 = function (doc, needle, atEnd, idx_hint) {
    if (atEnd === void 0) { atEnd = false; }
    if (idx_hint === void 0) { idx_hint = -1; }
    if (!idx_hint) { idx_hint = -1; }
    if (needle == null)
        return -1;
    else {
        var agent_1 = needle[0], seq_1 = needle[1];
        // This little optimization *halves* the time to run the editing trace benchmarks.
        if (idx_hint >= 0 && idx_hint < doc.content.length) {
            var hint_item = doc.content[idx_hint];
            if ((!atEnd && idEq2(hint_item.id, agent_1, seq_1))
                || (hint_item.content != null && atEnd && idEq2(hint_item.id, agent_1, seq_1))) {
                hits++;
		indexRangeHits++
                return idx_hint;
            }
	
             //Try nearby.
             const RANGE = 50
             for (let i = idx_hint < RANGE ? 0 : idx_hint - RANGE; i < doc.content.length && i < idx_hint + RANGE; i++) {
               const item = doc.content[i]
               if ((!atEnd && idEq2(item.id, agent_1, seq_1))
                   || (item.content != null && atEnd && idEq2(item.id, agent_1, seq_1))) {
                 hits++
		 indexRangeHits++
                 return i
               }
             }

        }
        misses++;
	indexRangeMisses++
        var idx = doc.content.findIndex(function (_a) {
            var content = _a.content, id = _a.id;
            return ((!atEnd && idEq2(id, agent_1, seq_1)) || (content != null && atEnd && idEq2(id, agent_1, seq_1)));
        });
         // : doc.content.findIndex(({id}) => idEq(id, needle))
        if (idx < 0) throw Error('Could not find item'); // Could use a ternary if not for this!
        return idx;
    }
};


var findItem = function (doc, needle, idx_hint) {
    if (idx_hint === void 0) { idx_hint = -1; }
    return (findItem2(doc, needle, false, idx_hint));
};



var findItemAtPos = function (doc, pos, stick_end) {
    if (stick_end === void 0) { stick_end = false; }
    var i = 0;
    // console.log('pos', pos, doc.length, doc.content.length)
    for (; i < doc.content.length; i++) {
        var item = doc.content[i];
        if (stick_end && pos === 0)
            return i;
        else if (item.isDeleted || item.content == null)
            continue;
        else if (pos === 0)
            return i;
        pos--;
    }
    if (pos === 0)
        return i;
    else
        throw Error('past end of the document');
};



// Original localInsert, slightly extended to support update operations and resyncing by range.
// Note: The Delete part only uses item id detected by operations generator

function localInsert(doc, agent, pos, content, isInitial, isUpdate) {
    var _a, _b, _c, _d, _e;
    //var i = findItemAtPos(doc, pos)
    var i
    var result= [];
    var cancelInsert=false
    var success=false
	
    // Part dealing with local ops being outdated because the data structure changed while the user was dragging.
    // NOTE: Not needed during initial loading (or when no buffered remote ops got integrated)
    if (!isInitial) { 	
	var tOp=positionTentativeOp (doc, agent, pos, content, isInitial, isUpdate)			
	i=tOp.finalPos
	cancelInsert=tOp.cancelInsert
    } else {
	//i = findItemAtPos(doc, pos)
	i = tempInsertIdx
    }

// Now comes the standard part od localinsert (positions fixed)
if (!cancelInsert) {

    // Do the delete first
    if (isUpdate) {
	const itemtoDelete = tempItemToDelete
	if (!itemtoDelete.isDeleted) {
    		itemtoDelete.isDeleted = true
    		doc.length -= 1
  	}
	result.push(itemtoDelete);
    }

    // Then the insert
    var newItem = integrateYjs(doc, {
        content: content,
        id: [agent, ((_a = doc.version[agent]) !== null && _a !== void 0 ? _a : -1) + 1],
        isDeleted: false,
        originLeft: (_c = (_b = doc.content[i - 1]) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : null,
        originRight: (_e = (_d = doc.content[i]) === null || _d === void 0 ? void 0 : _d.id) !== null && _e !== void 0 ? _e : null,
        insertAfter: true,
        seq: doc.maxSeq + 1, // Only for AM.
    }, i);
    success=true
    result.push(newItem);

    lastLocalInsertPos=lastInsertPos
} 

result.unshift (success)
return result;

}


var getArray = function (doc) { return (doc.content.filter(function (i) { return !i.isDeleted && i.content != null; }).map(function (i) { return i.content; })); };


var isInVersion = function (id, version) {
    if (id == null)
        return true;
    var seq = version[id[0]];
    return seq != null && seq >= id[1];
};


var canInsertNow = function (op, doc) { return (
// We need op.id to not be in doc.versions, but originLeft and originRight to be in.
// We're also inserting each item from each agent in sequence.
!isInVersion(op.id, doc.version)
    && (op.id[1] === 0 || isInVersion([op.id[0], op.id[1] - 1], doc.version))
    && isInVersion(op.originLeft, doc.version)
    && isInVersion(op.originRight, doc.version)); };



var integrateYjs = function (doc, newItem, idx_hint) {
    if (firstGlobalEdit == 0) firstGlobalEdit=performance.now ();
    lastGlobalEdit = performance.now ();
    var identicalLeft=false; // HM-mod
    var reorderByGeom=false; // HM-mod
    var _a;
    if (idx_hint === void 0) { idx_hint = -1; }
    var lastSeen = (_a = doc.version[newItem.id[0]]) !== null && _a !== void 0 ? _a : -1;
    if (newItem.id[1] !== lastSeen + 1)
        throw Error('Operations out of order');
    doc.version[newItem.id[0]] = newItem.id[1];
    var left = findItem(doc, newItem.originLeft, idx_hint - 1);
    if (useIndex) idx_hint=left;  // v1.02
    var destIdx = left + 1;
    var right = newItem.originRight == null ? doc.content.length : findItem(doc, newItem.originRight, idx_hint);
    var scanning = false;
    for (var i = destIdx;; i++) {
        // Inserting at the end of the document. Just insert.
        if (!scanning)
            destIdx = i;
        if (i === doc.content.length)
            break;
        if (i === right)
            break; // No ambiguity / concurrency. Insert here.
        var other = doc.content[i];
        var oleft = findItem(doc, other.originLeft, idx_hint - 1);
        var oright = other.originRight == null ? doc.content.length : findItem(doc, other.originRight, idx_hint);
        // The logic below can be summarized in these two lines:
        // if (oleft < left || (oleft === left && oright === right && newItem.id[0] <= o.id[0])) break
        // if (oleft === left) scanning = newItem.id[0] <= o.id[0]
        // Ok now we implement the punnet square of behaviour
        if (oleft < left) {
            // Top row. Insert, insert, arbitrary (insert)
            break;
        }
        else if (oleft === left) {
	    identicalLeft=true;
	    reorderByGeom = false; // HM-mod
            // Middle row.
            //if (newItem.id[0] > other.id[0]) { // Original conflict sort condition
	    
	    //if (!isBeforeConflicting (doc.content[oleft].content, newItem.content, other.content)) { 	
	    if (!isBeforeConflicting (doc, oleft, newItem, other)) { //This is the modified conflct handler
		// We record that id-based sort would have sorted differntly	
	    	if (newItem.id[0] <= other.id[0])  {
			reorderByGeom = true
		} 
                scanning = false;
                continue;
            }
            else if (oright === right) {
                break;
            }
            else {
                scanning = true;
                continue;
            }
        }
        else {
            // Bottom row. Arbitrary (skip), skip, skip
            continue;
        }
    }


    	if (reorderByGeom) {
		srConversions ++;
		// We also collect the ids of converted items to be able to do specific item count 
		// across all clients within a session
		currentItemContent=doc.content[destIdx-1].content;
		srConversionList.push(newItem.id); 
		socket.emit('Conversion data',  {geom:[newItem.content, currentItemContent], id:newItem.id} );
		socket.emit('Error data',  {type:1, mode:"Global", geom:newItem.content, id:newItem.id, opType: lastOpType, time: ((performance.now()-firstEdit)/1000).toFixed()} );
    	}

	
    // We've found the position. Insert here.
    doc.content.splice(destIdx, 0, newItem);
    if (!newItem.isDeleted)
        doc.length += 1;

	lastInsertPos=i; // HM added
	return newItem; // HM added

};



//*****************************************************************************************************************************
//*****************************************  END OF REFERENCE CRDTs ***********************************************************
//*****************************************************************************************************************************


// **************  Additional CRDT functions ***********************

var canDeleteNow = function (op, doc) { 
	return isInVersion(op.id, doc.version);
 };



function localDelete (doc, agent, itemToDelete){
  if (!itemToDelete.isDeleted) {
    itemToDelete.isDeleted = true
    doc.length -= 1
  }
  return itemToDelete;
}


function localDeleteFromOther (doc, itemtoDelete, idx_hint){
  
  deletedAtPos=false
  const itemPos=findItem(doc, itemtoDelete.id, idx_hint)
  const item = doc.content [itemPos]
  if (!item.isDeleted) {
    deletedAtPos=itemPos
    item.isDeleted = true
    doc.length -= 1
  }
  //return deletedAtPos+1
  return deletedAtPos
}


function getNextUndeletedItemIdx (doc, idxIn){
	for (var i = idxIn+1 ; i < doc.content.length; i++) {
		if (!doc.content[i].isDeleted) {return i}
	}

	// If the item is not found in the loop we've come to the end
	// So we now start searching from the beginning forward
	//for (var j = 0 ; j < doc.content.length; j++) {
	for (var j = 0 ; j < idxIn; j++) {
		if (!doc.content[j].isDeleted) {return j}
	}

	// This should not happen
	//return false;
	alert ("Critical error: Could not find PREVIOUS undeleted item's index");
}

function getPreviousUndeletedItemIdx (doc, idxIn){
	for (var i = idxIn-1 ; i > -1; i--) {
		if (!doc.content[i].isDeleted) {return i}
	}

	// If the item is not found in the loop we've come to the beginning
	// So now we start searching backwards from the end
	for (var j = doc.content.length-1 ; j > idxIn; j--) {
		if (!doc.content[j].isDeleted) {return j}
	}

	// This should not happen
	//return false;
	alert ("Critical error: Could not find NEXT undeleted item's index");
}



//***************************************************************************************************************************************
//  								Interactions and geometry redrawing
//***************************************************************************************************************************************


var selektiranje2 = new ol.interaction.Select({style: stiloviPoligonaSelectBez});
var editiranje = new ol.interaction.Modify({features: selektiranje2.getFeatures(), style: stiloviPoligonaModify});
map.addInteraction(selektiranje2);
map.addInteraction(editiranje);
selektiranje2.setActive(true);
editiranje.setActive(true);

// *********************************************************************************************************
// Stuff for syncing clicks and modify events to prevent integrating remote ops while local being generated
// Basically, this makes sure that no remote op can get integrated as soon as user clicks, potentially initiating a modify event.
// Handling modifystart is not sufficient because of the delay set by OL. Thus we set currentlyEditing=true as soon as the user clicks.
// In a real world implementation this will probably need to be implemented in a more stable/systematic manner (possibly by digging in into Openlayers itself).
// *********************************************************************************************************
var mouseClickController = new ol.interaction.Pointer();
map.addInteraction(mouseClickController);
mouseClickController.setActive(true);

// Each time the user clicks we presume he is about to start dragging
mouseClickController.handleDownEvent=function(evt){
	currentlyEditing=true
	document.getElementById('ispisKoordinata').style.color='red';
}

// If he moves the map he's not gonna drag
map.on('movestart',function(evt){
	currentlyEditing=false
	document.getElementById('ispisKoordinata').style.color='green';
})

// If he either selects or deselects he is not going to drag next.
// So if there something in the in-buffer, we apply here.
selektiranje2.on('select',function(evt){	
	currentlyEditing=false
	document.getElementById('ispisKoordinata').style.color='green';

	if (unAppliedMessages) {
		var didAnything=integrateMessagesFromBuffer();
		if (didAnything) applyCurrentState (); 
		unAppliedMessages=false;
	} 

})


//**********************************
// Tentative operation pre-generator
//**********************************

function makeTentativeOp(doc, posLeft, posRight, mode){
// Mode=1 update operation -> right range end is one undeleted element further to the right
// Mode=2 insert operation -> right range end is at insert position (which is guranteed to be undeleted) 
	
	// If origin point is hit then no real posLeft exists, and OL returns last polygon point in 2nd segment
	// Hence correct item pos is on 1st segment
	if (Math.abs(posLeft-posRight)>1) {
			tempInsertPos=posLeft
			var startT=performance.now ()
			var rightItemIdx=findItemAtPos(doc, posLeft)
			tempInsertIdx=rightItemIdx
			var endT=performance.now ()
			lastViewToModel=(endT-startT)
			if (mode==1) {
				tempItemToDelete=doc.content[rightItemIdx] // To place new item after the deleted one
				console.log ("ORIGIN UPDATE") 
				// For update ops the right range end is the next undeleted item from the item being updated
				var rightRangeItemIdx=getNextUndeletedItemIdx(doc, rightItemIdx)
				console.log ("ORIGIN UPDATE RR index " + rightRangeItemIdx) 
				rangeEndRightId=doc.content[rightRangeItemIdx].id
				var leftRangeItemIdx=getPreviousUndeletedItemIdx(doc, doc.content.length)
				rangeEndLeftId=doc.content[leftRangeItemIdx].id
			} else if (mode==2) { 
				alert ("This situation should not be possible!!!")
				console.log ("INSERT AFTER ORIGIN")
				// For inserts, right range end is the item on which we position the insert (the one that gets pushed to the right)
				rangeEndRightId=doc.content[rightItemIdx].id
				var leftRangeItemIdx=getPreviousUndeletedItemIdx(doc, rightItemIdx)
				rangeEndLeftId=doc.content[leftRangeItemIdx].id
			}
			
	}
	// In standard cases correct item pos is on 2nd segment
	else {  
			// This case can only be a simple insert (never na update). 
			// Updating of geometry origin point always occurs on position zero.
			// NOTE: tempItemLeft and tempItemRight are synonyms of originLeft and originRight (as they are at this stage)
			tempInsertPos=posRight
			var startT=performance.now ()
			var rightItemIdx=findItemAtPos(doc, posRight)
			tempInsertIdx=rightItemIdx
			var endT=performance.now ()
			lastViewToModel=(endT-startT)

			
			// However, when inserting point on the last segment then originRight doesn't really exist. 
			// Still, correct pos is on the 2nd segment
			if (tempInsertPos>=doc.length) { 
				console.log ("INSERT ON LAST SEGMENT")
				var rightRangeItemIdx=getNextUndeletedItemIdx(doc, -1)
				rangeEndRightId=doc.content[rightRangeItemIdx].id
				var leftRangeItemIdx=getPreviousUndeletedItemIdx(doc, doc.content.length) // was doc.content.length-1
				rangeEndLeftId=doc.content[leftRangeItemIdx].id
				//console.log ("REL AT =" + leftRangeItemIdx)
				//console.log ("REL ID =" + rangeEndLeftId)

			} else { 
				console.log ("IS NORMAL")
				//var startT=performance.now ()
				//var rightItemIdx=findItemAtPos(doc, posRight)
				//var endT=performance.now ()
				//lastViewToModel=(endT-startT)
				var leftRangeItemIdx=getPreviousUndeletedItemIdx(doc, rightItemIdx)
				rangeEndLeftId=doc.content[leftRangeItemIdx].id
				if (mode==1) {
					tempItemToDelete=doc.content[rightItemIdx] 
					// For update ops the right range end is the next undeleted item from the item being updated
					var rightRangeItemIdx=getNextUndeletedItemIdx(doc, rightItemIdx)
					rangeEndRightId=doc.content[rightRangeItemIdx].id
					console.log ("IS UPDATE")
					//console.log ("RER AT =" + rightRangeItemIdx)
					//console.log ("RER ID =" + rangeEndRightId)
				} else if (mode==2) { 
					// For inserts, right range end is the item on which we position the insert (the one that gets pushed to the right)
					rangeEndRightId=doc.content[rightItemIdx].id
					console.log ("IS INSERT")
					//console.log ("RER AT =" + rightItemIdx)
					//console.log ("RER ID =" + rangeEndRightId)
				}
			}
	}

}



//**************************************
// Tentative operation final positioning
//**************************************


function positionTentativeOp (doc, agent, pos, content, isInitial, isUpdate) {
    //var i = findItemAtPos(doc, pos)
    var i 
    var cancelInsert=false
    var success=false
	
    // Part dealing with local ops being outdated because the data structure changed while the user was dragging.
    // NOTE: Not needed during initial loading (or when no buffered remote ops got integrated)
    		
		// ++Step 1: Finding current indexes of rangeEndLeft and rangeEndRight.
		// Therewith we set the interval for placing our item.
		// *** The left range end part ***
			//var rangeEndLeftIdx=findItem (doc, rangeEndLeftId, i)
			var rangeEndLeftIdx=findItem (doc, rangeEndLeftId, lastLocalInsertPos)
			console.log ("REL FINAL IDX=" + rangeEndLeftIdx)

		// *** The right range end part ***
			//var rangeEndRightIdx=findItem (doc, rangeEndRightId, i)
			var rangeEndRightIdx=findItem (doc, rangeEndRightId, lastLocalInsertPos)
			console.log ("RER FINAL IDX=" + rangeEndRightIdx)

			// ++Step 2
			// We want to push our op to its natural position between the range ends. 
			// Since the op to be inserted is still "pending" we are free to place it anywhere within the range.
			// We simply iterate over the elements as they are ordered in array, completely disregard 
			// the left-right pointers hierarchy and find its most appropriate position.
			
			var lastBestAngle = 3.14159 // Worst case (extremely small angle)
			var isFound=false
			var j=rangeEndLeftIdx // To be able to design the while loop (will be shifted to first index after range end left within while loop)
			var firstNextUndeletedPointIdx=getNextUndeletedItemIdx (doc, rangeEndLeftIdx)
			var secondNextUndeletedPointIdx=getNextUndeletedItemIdx (doc, firstNextUndeletedPointIdx)

			// We detect simple situations (updates and inserts within range or outside of it entirely) where range did not get extended and handle them by skipping the complex testing/positioning loop.
			// Since many buffered will be of such type, performance should be less hindered by the whole tentative ops mechanism.
			// Local point is simply inserted on the position of the first next undeleted point to the right of the position of the subject point's range end left.

			if (isUpdate) {var pointToBeDeleted=tempItemToDelete.content; var targetPoint=doc.content[firstNextUndeletedPointIdx].content}

			if (!isUpdate && rangeEndRightIdx==firstNextUndeletedPointIdx && !rangeGotExtended) {
				console.log ("******SIMPLE INSERT RESYNC*****")
				isFound=true 
				i=firstNextUndeletedPointIdx
			}
			else if (isUpdate && rangeEndRightIdx==secondNextUndeletedPointIdx && !rangeGotExtended && vertexesIdentical (pointToBeDeleted,targetPoint)) {
				console.log ("******SIMPLE UPDATE RESYNC*****"); 
				isFound=true
				i=firstNextUndeletedPointIdx
			}
			else {
				// Since we ended up here, a buffered op extended the range of tentative local op, hence we must reposition it.
				// We start counting buffered op at -1 since we always also process right range end which isnt a real buffered op (previously was incorrectly set ot -2)
				var bufferedOpsCtr=-1
				var start = performance.now();
				do {
				j++
				if (j>=doc.content.length) j=0

				console.log ("PROCESSING IDX " + j)
				// Mandatory condition: no intersections at current position
				if (!doc.content[j].isDeleted) {
					bufferedOpsCtr++
					if (checkIntersection (doc, content, j, rangeEndLeftIdx, rangeEndRightIdx)) {
						// Secondary condition: we want the position where the most straight split occurs (angle closest to Pi or 180 degrees)
						var angleAtThis = angleAtPt (doc, content, j)
						if (angleAtThis<lastBestAngle) {
							lastBestAngle=angleAtThis
							console.log ("GOT BETTER ANGLE " + angleAtThis)
							i = j
							isFound=true
						} 
					} 
				} 

				} while (j!=rangeEndRightIdx) 
				var end = performance.now();
				socket.emit('Error data',  {type:3, siteId: agent, geom:content, opType: lastOpType, time: ((performance.now()-firstEdit)/1000).toFixed(), bufferedOps:bufferedOpsCtr, duration: end-start } );
				localReorders++

			}

			// If the position wasn't found (e.g. all elements within range are deleted) 
			// we place the item right before the right range end
			if (!isFound) {
				i=rangeEndRightIdx; 
				console.log ("POS NOT FOUND, PLACING AT " + i) 
				socket.emit('Error data',  {type:2, siteId: agent, geom:content, opType: lastOpType, time: ((performance.now()-firstEdit)/1000).toFixed()} );
			} 


			console.log ("FINAL POS=" + i + "Best angle = " + lastBestAngle)
			
return {finalPos:i, cancelInsert: cancelInsert}

}





//*******************************
// MODIFYSTART event handler
//*******************************
editiranje.on('modifystart',function(evt){

		dragStartTime = performance.now();
        
		if (firstEdit==0) firstEdit=performance.now();
		coordsBefore=selektiranje2.getFeatures().getArray()[0].getGeometry().getCoordinates()[0].deepClone();
		
		// With OL point delete modifications we can catch segments here only. OL updates are also handled here.
		if (evt.target.dragSegments_.length>1){
			console.log ("IN MODSTART")
			var posLeft=evt.target.dragSegments_[0][0].index; 
			var posRight=evt.target.dragSegments_[1][0].index; 
			makeTentativeOp(crdtDoc, posLeft, posRight,1)
			opParamsFound=true
		} else {
			opParamsFound=false
		}
		
})


//****************************
// MODIFYEND event handler
//****************************
editiranje.on('modifyend',function(evt){
		var result=[]
		var cancelOp=false;
		lastEdit=performance.now();
        	dragEndTime= performance.now();
        	timeDragging = timeDragging + (dragEndTime-dragStartTime);


		// STEP 1: Get the tentative local op parameters (if not already created in modifystart event handler)
		// OL inserts are handled here. 
		if  (evt.target.dragSegments_.length>1 && !opParamsFound) {
			console.log ("IN MODEND")
			var posLeft=evt.target.dragSegments_[0][0].index; 
			var posRight=evt.target.dragSegments_[1][0].index;
			makeTentativeOp(crdtDoc, posLeft, posRight,2)
						
		// If getting posLeft and posRight failed using dragsegments (either modstart or modend) we do it here 
		// the operation has to be cancelled. This sometimes happens (probably some OL level event syncing problem)
		} else if (!opParamsFound || selektiranje2.getFeatures().getArray()[0]===undefined) {

			cancelOp=true
			result.push(false)
			socket.emit('Error data',  {type:4, siteId: clientId, errText: "Drag segments error"} );
		}

		
		// STEP 2: Integrate buffered remote ops
		// First, in order to create the session wide most current state on this client, process any received ops if there ar any (but do not apply to OL feature coords array or redraw)
		//var bufferSize=unprocessedMessages.length;
		if (unAppliedMessages) {
			var didAnything=integrateMessagesFromBuffer();
			unAppliedMessages=false;
		}


		var startT = performance.now();	
		var atTimeInstant=((startT-firstGlobalEdit)/1000).toFixed();

	if (!cancelOp) {
		// If local op got succesuflly created (op not canceled)
		// We must also get the coords of the inserted point by tempInsertPos before we apply buffered remote ops.
		// NOTE: The point coordinate in only known when the users completes the edit (after modifyend event fires), we couldn't have gotten it earlier!
		coords=selektiranje2.getFeatures().getArray()[0].getGeometry().getCoordinates()[0];
		if (coordsBefore.length==coords.length || coordsBefore.length<coords.length) var point=coords[tempInsertPos]


		// STEP 3: Integrate the final local op
		// Integrate the local operation

		editsDone ++;
		document.getElementById("editsdone").textContent=editsDone;
		
		var dodani={};
		var brisani={};
		var pTcoords
		var startT2 = performance.now();	

		//UPDATE
		if (coordsBefore.length==coords.length) {
			lastOpType="UPDlocal";
			
			// Remote deletes and a local insert near the end of the doc could cause the tempInsertPos to fall outside of the doc.
			// So we put it at the end and let the algorithm find it the "hard" way.
			if (tempInsertPos>crdtDoc.length) tempInsertPos=crdtDoc.length
			
			// The !didAnything (if not didAnything then consider it as initialLoad and vice versa) parameter tells the localinsert 
			// to consider the call as a initialload (since no buffered ops got integrated) so that all the complex, tentative stuff can be skipped
			result = localInsert(crdtDoc, clientId, tempInsertPos, point, !didAnything, true);
			brisani=result[1];
			dodani=result[2];
			
			updatesDone++;
			pTcoords=dodani.content;


		//DELETE
		} else if (coordsBefore.length>coords.length) {
			lastOpType="DELlocal";
			
			brisani=localDelete (crdtDoc, clientId, tempItemToDelete);
			result.push(true)
			deletesDone++;
			pTcoords=brisani.content;


		//INSERT
		} else if (coordsBefore.length<coords.length) {
			lastOpType="INSlocal";

			// Remote deletes and a local insert near the end of the doc could cause the tempInsertPos to fall outside the doc
			// So we put it at the end and let the algorithm find it the "hard" way.
			if (tempInsertPos>crdtDoc.length) tempInsertPos=crdtDoc.length
			
			// The !didAnything parameter tells the localinsert to consider the call as a initialload (since no buffered ops got integrates)
			var result = localInsert(crdtDoc, clientId, tempInsertPos, point, !didAnything, false);
			dodani=result[1];

			insertsDone++;
			pTcoords=dodani.content;

		}

		var endT2 = performance.now();			
		var localExecTime=endT2 - startT2;

		var infoPt = new ol.geom.Point(pTcoords);
		var infoFeat= new ol.Feature({geometry: infoPt});
		//infoFeat.setId(data.id);
		infoFeat.set("opType", lastOpType);
		infoFeat.set("atTimeInstant", atTimeInstant);
		//infoFeat.set("bufferFlushTime", bufferFlushTime.toFixed(2));
		//infoFeat.set("bufferSize", bufferSize);
		infoFeat.set("localExecutionTime", localExecTime.toFixed(2));
		infoFeat.set("view2ModelTime", lastViewToModel.toFixed(2));

		vectorSourceOpsPts.addFeature(infoFeat);	
		localOpsCoordsList.push(pTcoords);


	}


		// STEP 4
		// Finishing, resetting, redrawing, transmitting local op

		//tempItemLeftStatus=undefined
		//tempItemRightStatus=undefined
		//tempItemLeftId=false
		//tempItemRightId=false
		tempInsertPos=false
		rangeEndRightId=false
		rangeEndLeftId=false
		tempItemToDelete=false
		opParamsFound=false
		rangeGotExtended=false
		




		if (result[0]) {
			var trans ={new: dodani, del: brisani, clientId:clientId }
			postModifyProcessorCRDT (trans)
		// Even if we generated no op (e.g. it was canceled by snap-canceling or dragsegments error) we must redraw now, to draw the remote updates
		} else  {
			applyCurrentState (); 
			currentlyEditing=false;
			document.getElementById('ispisKoordinata').style.color='green';
		}


})





//****************************************************************
//        Various utils and helpers
//****************************************************************



// Measure timing 
function mjerenjePerformansi (sT,eT) {
	var vrijeme=(eT - sT);
	if (vrijeme>peekTime) peekTime=vrijeme;
	brojRacunanja++;
	ukupnoVrijeme=ukupnoVrijeme+vrijeme;
	//var prosjek=ukupnoVrijeme/brojRacunanja;
}


function mjerenjePerformansiOL (sT,eT) {
	var vrijeme=(eT - sT);
	if (vrijeme>peekTimeOL) peekTimeOL=vrijeme;
	brojRacunanjaOL++;
	ukupnoVrijemeOL=ukupnoVrijemeOL+vrijeme;
	//var prosjek=ukupnoVrijeme/brojRacunanja;
}

function mjerenjePerformansiMV (sT,eT) {
	var vrijeme=(eT - sT);
	if (vrijeme>peekTimeMV) peekTimeMV=vrijeme;
	brojRacunanjaMV++;
	ukupnoVrijemeMV=ukupnoVrijemeMV+vrijeme;
	//var prosjek=ukupnoVrijeme/brojRacunanja;
}






// Are two coords identical?
function vertexesIdentical (t1,t2) {
	var odgovor=false;
	if (t1[0]==t2[0] && t1[1]==t2[1]) {odgovor=true}
	return odgovor;
}


function distancePtPt (t1,t2) {
    return Math.sqrt( ((t1[0]-t2[0])**2)+((t1[1]-t2[1])**2) );
}


function isBeforeConflicting (doc, originPos, thisItem, conflictingItem) {	
	    if (originPos>-1) {
		// If originLeft is available we calculate the distance
		var parent=doc.content[originPos].content;
		var dThis=distancePtPt (parent, thisItem.content);
		var dConf=distancePtPt (parent, conflictingItem.content);
		return dThis<=dConf;
	    } else {
		// If not (op at index 0), have to order by id
		return thisItem.id[0] > conflictingItem.id[0]
	    }
}


//   Shallow clone array  
Array.prototype.clone = function(){
  return [...this];
};

// deep clone array  
// from: https://stackoverflow.com/questions/3978492/fastest-way-to-duplicate-an-array-in-javascript-slice-vs-for-loop

Array.prototype.deepClone = function(){
  return this.map(e => Array.isArray(e) ? e.clone() : e);
};



// **************  INTERSECTION CONTROL  ******************

// returns true if NO INTERSECTION occurs for this config
function checkIntersection (doc, newItemPt, otherItemIdx, rangeEndLeftIdx, rangeEndRightIdx) {
	
	var otherPt = doc.content[otherItemIdx].content
	var prevPtIdx= getPreviousUndeletedItemIdx(doc,otherItemIdx)
	var PrevPt=doc.content[prevPtIdx].content
	//console.log ("OtherIDX="+otherItemIdx + " PrevPTiDX=" + prevPtIdx)
	//console.log ("Control line 1 " + otherPt + "-" +  newItemPt)
	//console.log ("Control line 2 " + PrevPt + "-" +  newItemPt)
	if (rangeEndLeftIdx>0) var p1Idx=getNextUndeletedItemIdx (doc, rangeEndLeftIdx-1)
	//else var p1Idx=getNextUndeletedItemIdx (doc, rangeEndLeftIdx)  // Možda bi u ovom slučaju trebalo tražiti odr kraja prema početku??
	else var p1Idx=getPreviousUndeletedItemIdx (doc, doc.content.length)  // promijenjeno
	
	do {
		var p2Idx=getNextUndeletedItemIdx (doc, p1Idx) 
		var p1Pt=doc.content[p1Idx].content;  
		var p2Pt=doc.content[p2Idx].content;  
		//console.log ("DOING LINE " + p1Pt + "-" + p2Pt)
		//console.log ("At " + p2Idx + "-" + p1Idx)
		if (!(otherItemIdx==p2Idx && prevPtIdx==p1Idx)) {
			var intersection1=false
			var intersection2=false
			if (p1Idx != prevPtIdx && p2Idx != prevPtIdx) intersection2=doIntersect(PrevPt, newItemPt, p1Pt, p2Pt)
			if (otherItemIdx != p2Idx && otherItemIdx != p1Idx) intersection1=doIntersect(newItemPt, otherPt, p1Pt, p2Pt)
			//console.log ("RESULT " + intersection1 + "-"+ intersection2)
			if (intersection1 || intersection2) {console.log ("NOT GOOD"); return false}
		} 
		p1Idx=p2Idx
	} while (p2Idx<rangeEndRightIdx)


	console.log ("ACCEPTABLE")
	return true
		
}


// Given three collinear points p, q, r, the function checks if
// point q lies on line segment 'pr'
function onSegment(p, q, r)
{
    if (q[0] <= Math.max(p[0], r[0]) && q[0] >= Math.min(p[0], r[0]) &&
        q[1] <= Math.max(p[1], r[1]) && q[1] >= Math.min(p[1], r[1]))
    return true;
    
    return false;
}
  
// To find orientation of ordered triplet (p, q, r).
// The function returns following values
// 0 --> p, q and r are collinear
// 1 --> Clockwise
// 2 --> Counterclockwise
function orientation(p, q, r)
{
    // See https://www.geeksforgeeks.org/orientation-3-ordered-points/
    // for details of below formula.
    let val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    if (val == 0) return 0; // collinear
    
    return (val > 0)? 1: 2; // clock or counterclock wise
}
  
// The main function that returns true if line segment 'p1q1'
// and 'p2q2' intersect.
function doIntersect(p1, q1, p2, q2)
{
  

    // Find the four orientations needed for general and
    // special cases
    let o1 = orientation(p1, q1, p2);
    let o2 = orientation(p1, q1, q2);
    let o3 = orientation(p2, q2, p1);
    let o4 = orientation(p2, q2, q1);

    
    // General case
    if (o1 != o2 && o3 != o4)
        return true;
    
    // Special Cases
    // p1, q1 and p2 are collinear and p2 lies on segment p1q1
    if (o1 == 0 && onSegment(p1, p2, q1)) return true;
    
    // p1, q1 and q2 are collinear and q2 lies on segment p1q1
    if (o2 == 0 && onSegment(p1, q2, q1)) return true;
    
    // p2, q2 and p1 are collinear and p1 lies on segment p2q2
    if (o3 == 0 && onSegment(p2, p1, q2)) return true;
    
    // p2, q2 and q1 are collinear and q1 lies on segment p2q2
    if (o4 == 0 && onSegment(p2, q1, q2)) return true;
    
    return false; // Doesn't fall in any of the above cases
}


// **************  ANGLE CONTROL  ******************

function angle3Pts (P1,P2,P3) {
	var angle =  Math.atan2(P3[1] - P1[1], P3[0] - P1[0]) - Math.atan2(P2[1] - P1[1], P2[0] - P1[0]);
	return angle;
}


function angleAtPt (doc, newItemPt, currentItemIdx) {
	
	var prevPtIdx= getPreviousUndeletedItemIdx(doc,currentItemIdx)
	var prevPt=doc.content[prevPtIdx].content
	var currentPt=doc.content[currentItemIdx].content;

	//console.log ( newItemPt,  currentPt, PrevPt);

	var angle = angle3Pts (newItemPt,prevPt,currentPt);
	var redAngle = Math.abs (3.14-Math.abs(angle));
	//console.log ("Raw Ange at this=" + angle)
	//console.log ("Red Ange at this=" + redAngle)

	return redAngle

}



function saveFeatures(sourceIn){
		
	var geoJsonFeature = gjsonFormat.writeFeatures(vectorSourcePreuzeti.getFeatures());
	var blob = new Blob([geoJsonFeature], {type: "text/plain;charset=utf-8"});
    	window.saveAs(blob, "proba.txt");
}



// *************************** AUTOMATIC CLIENT ADDON ***********************************


class OperationGenerator {
  constructor({
    positionRange = { from: 0, to: 100 },
    burstLength = { min: 3, max: 6 },
    intervalMs = 1000,
    operationWeights = { insert: 0.4, update: 0.4, delete: 0.2 }
  }) {
    
    this.positionRange = positionRange;
    this.burstLength = burstLength;
    this.intervalMs = intervalMs;
    this.operationWeights=operationWeights;

    this.currentPosition = this.pickRandomPosition();
    this.remainingInBurst = this.pickBurstLength();
    this.operationWeights=operationWeights;
  }

setPositionRange(newRange) {
  this.positionRange = newRange;
  const { from, to } = newRange;
  this.currentPosition = Math.floor(Math.random() * (to - from + 1)) + from;
}

  randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  pickRandomPosition() {
    return this.randomInt(this.positionRange.from, this.positionRange.to);
  }

  pickBurstLength() {
    return this.randomInt(this.burstLength.min, this.burstLength.max);
  }


pickOperationType() {
  const weights = this.operationWeights;
  const r = Math.random();

  if (r < weights.insert) return 'insert';
  if (r < weights.insert + weights.update) return 'update';
  return 'delete';
}


  generatePerpendicularInsertOperation(currentPosition, nextPosition, distance) {
    
	var x1= crdtDoc.content [currentPosition].content[0]
	var y1= crdtDoc.content [currentPosition].content[1]
	var x2= crdtDoc.content [nextPosition].content[0]
	var y2= crdtDoc.content [nextPosition].content[1]


    // Compute direction vector AB
    const dx = x2 - x1;
    const dy = y2 - y1;

    // Compute the perpendicular vector (always to the left)
    const perpendicularX =  dy;
    const perpendicularY = -dx;


    // Normalize the perpendicular vector
    const magnitude = Math.sqrt(perpendicularX * perpendicularX + perpendicularY * perpendicularY);
    const unitPerpendicularX = perpendicularX / magnitude;
    const unitPerpendicularY = perpendicularY / magnitude;

    // Scale by the desired distance
    const newX = x1 + unitPerpendicularX * distance;
    const newY = y1 + unitPerpendicularY * distance;

    return [newX, newY];
  }

  generateOperation() {
    const type = this.pickOperationType();
    const position = this.currentPosition;

    const op = { };

    // Generate operations
    if (type === 'insert') {
      var realPosition = findItemAtPos(crdtDoc, position)
      const nextPosition = realPosition+1; // Dont care if we hit a tombstone
      const distance = this.randomInt(500, 600);  // You can set the distance range here
      const newCoord = this.generatePerpendicularInsertOperation(realPosition, nextPosition, distance);
      op.type=type
      op.coords = newCoord; // Set the newly calculated insert position
      op.position = realPosition;
      op.distance=distance/50;
    }

    if (type === 'update') {
      var realPosition = findItemAtPos(crdtDoc, position)
      const nextPosition = realPosition+1; // Dont care if we hit a tombstone
      const distance = this.randomInt(500, 600);  // You can set the distance range here
      const newCoord = this.generatePerpendicularInsertOperation(realPosition, nextPosition, distance);
      op.type=type
      op.coords = newCoord; // Set the newly calculated insert position
      op.position = realPosition;
      op.distance=distance/50;
    }

    if (type === 'delete') {
      var realPosition = findItemAtPos(crdtDoc, position)
      op.type=type
      op.coords = null;
      op.position = realPosition;
      op.distance=10;
    }

    return op;
  }

  emitOperation() {
    if (this.remainingInBurst <= 0) {
      this.currentPosition = this.pickRandomPosition();
      this.remainingInBurst = this.pickBurstLength();
    }

    const op = this.generateOperation();
	var dodani={};
	var brisani={};
	var pTcoords;
	var result=[];
	
	if (op.type === 'insert') {
		tempInsertIdx=op.position
    		var result = localInsert(crdtDoc, clientId, op.position, op.coords, true, false);
    		dodani=result[1];
		pTcoords=dodani.content;
		var trans ={new: dodani, del: brisani, clientId:clientId }
		postModifyProcessorCRDT (trans)
	} else if (op.type === 'delete') {
		tempItemToDelete=crdtDoc.content[op.position]
		brisani=localDelete (crdtDoc, clientId, tempItemToDelete);
		result.push(true)
		pTcoords=brisani.content;
		var trans ={new: dodani, del: brisani, clientId:clientId }
		postModifyProcessorCRDT (trans)
	} else if (op.type === 'update') {
		tempInsertIdx=op.position
		tempItemToDelete=crdtDoc.content[op.position]
    		var result = localInsert(crdtDoc, clientId, op.position, op.coords, true, true);
    		brisani=result[1];
		dodani=result[2];
		pTcoords=dodani.content;
		var trans ={new: dodani, del: brisani, clientId:clientId }
		postModifyProcessorCRDT (trans)
	}

	autoOpsGenerated++

	// Uncomment only with powerfull enough hardware, takes some resources.
	/*
	positionFeature.setStyle(getStyleForOp({
  	type: op.type,
  	distance: op.distance,
	}));

	positionFeature.setGeometry(new ol.geom.Point(pTcoords));
	*/

    this.remainingInBurst--;
  }



startLoop() {
  this._isRunning = true;
  const loopOnce = () => {
    if (!this._isRunning) return;

    this.emitOperation();

    // Pick a random delay within the interval range
    const nextDelay = this.randomInt(this.intervalMs.min, this.intervalMs.max);

    this._timeout = setTimeout(loopOnce, nextDelay);
  };

  loopOnce();
}

stopLoop() {
  this._isRunning = false;
  clearTimeout(this._timeout);
}

} // Class end





var gen = new OperationGenerator({
  positionRange: { from: 7000, to: 9000 },
  burstLength: { min: 1, max: 10 },
  intervalMs: { min: 1500, max: 3500 },
  operationWeights: {insert: 0.4, update: 0.4, delete: 0.2}
});


document.getElementById('startauto').onclick = function() {
	var groupNumber=prompt ("Group numbers to start in sequence (comma separated)");
	//socket.emit('Error data',  {type:5, targetGroup: groupNumber} );		      // The client to know it will start generating
	//socket.emit('start ops group',  {name: groupNumber, minDelay:1500, maxDelay:3500} );  // Start the server

	var groups=groupNumber.split (",")
	socket.emit('start op generation sequence', {groups: groups, interval: 60000});
	
};

document.getElementById('stopauto').onclick = function() {
	socket.emit('stop all op generation',  { targetGroup: "dummy"} );  // This stop the server
	//socket.emit('stop op generation sequence');
        socket.emit('Error data',  {type:6, targetGroup: "dummy"} );	   // Also inform all clients (to make it redraw what it collected)
};


const positionFeature = new ol.Feature();


function getStyleForOp({ type, distance }) {
  const colorMap = {
    insert: 'green',
    update: 'orange',
    delete: 'red',
  };

  return new ol.style.Style({
    image: new ol.style.Circle({
      //radius: 6 + distance * 2, // base size + scaling from distance
      radius: distance, // base size + scaling from distance
      fill: new ol.style.Fill({
        color: colorMap[type] || 'gray',
      }),
      stroke: new ol.style.Stroke({
        color: '#fff',
        width: 2,
      }),
    }),
  });
}


var autoDisplaySource = new ol.source.Vector();

new ol.layer.Vector({
  map: map,
  source: autoDisplaySource,
});



socket.on('generate-op-now', () => {
    //generateAndEmitOp(); 
    gen.emitOperation();
});




    </script>
  </body>
</html>











		






							
							  









